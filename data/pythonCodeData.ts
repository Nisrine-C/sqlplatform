
/**
 * Python code snippets for the animated background
 * Contains financial analysis and trading strategy code examples
 */
export const pythonCode = [
  "import pandas as pd",
  "import numpy as np",
  "import yfinance as yf",
  "from scipy.optimize import minimize",
  "import matplotlib.pyplot as plt",
  "from datetime import datetime, timedelta",
  "",
  "class PortfolioOptimizer:",
  "    def __init__(self, tickers, start_date, end_date):",
  "        self.tickers = tickers",
  "        self.start_date = start_date",
  "        self.end_date = end_date",
  "        self.data = None",
  "        self.returns = None",
  "",
  "    def fetch_data(self):",
  "        self.data = yf.download(self.tickers, ",
  "                               start=self.start_date,",
  "                               end=self.end_date)['Adj Close']",
  "        self.returns = self.data.pct_change().dropna()",
  "        return self.returns",
  "",
  "def calculate_sharpe_ratio(returns, risk_free_rate=0.02):",
  "    excess_returns = returns.mean() - risk_free_rate/252",
  "    volatility = returns.std()",
  "    return excess_returns / volatility * np.sqrt(252)",
  "",
  "def portfolio_performance(weights, returns):",
  "    portfolio_return = np.sum(returns.mean() * weights) * 252",
  "    portfolio_volatility = np.sqrt(",
  "        np.dot(weights.T, np.dot(returns.cov() * 252, weights))",
  "    )",
  "    sharpe_ratio = portfolio_return / portfolio_volatility",
  "    return portfolio_return, portfolio_volatility, sharpe_ratio",
  "",
  "class TradingStrategy:",
  "    def __init__(self, symbol, short_window=20, long_window=50):",
  "        self.symbol = symbol",
  "        self.short_window = short_window",
  "        self.long_window = long_window",
  "        self.signals = None",
  "",
  "    def moving_average_strategy(self, data):",
  "        signals = pd.DataFrame(index=data.index)",
  "        signals['price'] = data['Close']",
  "        signals['short_mavg'] = data['Close'].rolling(",
  "            window=self.short_window).mean()",
  "        signals['long_mavg'] = data['Close'].rolling(",
  "            window=self.long_window).mean()",
  "",
  "        signals['signal'] = 0.0",
  "        signals['signal'][self.short_window:] = np.where(",
  "            signals['short_mavg'][self.short_window:] > ",
  "            signals['long_mavg'][self.short_window:], 1.0, 0.0)",
  "",
  "        signals['positions'] = signals['signal'].diff()",
  "        return signals",
  "",
  "def calculate_var(returns, confidence_level=0.05):",
  "    \"\"\"Calculate Value at Risk using historical method\"\"\"",
  "    return np.percentile(returns, confidence_level * 100)",
  "",
  "def black_scholes_call(S, K, T, r, sigma):",
  "    \"\"\"Black-Scholes formula for European call option\"\"\"",
  "    from scipy.stats import norm",
  "    d1 = (np.log(S/K) + (r + sigma**2/2)*T) / (sigma*np.sqrt(T))",
  "    d2 = d1 - sigma*np.sqrt(T)",
  "    call_price = S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)",
  "    return call_price",
  "",
  "def monte_carlo_simulation(S0, mu, sigma, T, n_simulations=10000):",
  "    \"\"\"Monte Carlo simulation for stock price paths\"\"\"",
  "    dt = T / 252",
  "    prices = np.zeros((n_simulations, 253))",
  "    prices[:, 0] = S0",
  "",
  "    for t in range(1, 253):",
  "        z = np.random.standard_normal(n_simulations)",
  "        prices[:, t] = prices[:, t-1] * np.exp(",
  "            (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * z)",
  "",
  "    return prices",
  "",
  "class RiskManager:",
  "    def __init__(self, portfolio_value):",
  "        self.portfolio_value = portfolio_value",
  "        self.positions = {}",
  "",
  "    def calculate_position_size(self, risk_per_trade=0.02, ",
  "                               entry_price=None, stop_loss=None):",
  "        if entry_price and stop_loss:",
  "            risk_per_share = abs(entry_price - stop_loss)",
  "            position_size = (self.portfolio_value * risk_per_trade",
  "                           ) / risk_per_share",
  "            return min(position_size, self.portfolio_value * 0.1)",
  "",
  "def backtest_strategy(data, signals):",
  "    \"\"\"Simple backtesting framework\"\"\"",
  "    initial_capital = 100000.0",
  "    positions = pd.DataFrame(index=signals.index).fillna(0.0)",
  "    positions['holdings'] = 100 * signals['signal']",
  "",
  "    portfolio = positions.multiply(data['Close'], axis=0)",
  "    pos_diff = positions.diff()",
  "",
  "    portfolio['holdings'] = (positions.multiply(",
  "        data['Close'], axis=0)).sum(axis=1)",
  "    portfolio['cash'] = initial_capital - (pos_diff.multiply(",
  "        data['Close'], axis=0)).sum(axis=1).cumsum()",
  "",
  "    portfolio['total'] = portfolio['cash'] + portfolio['holdings']",
  "    portfolio['returns'] = portfolio['total'].pct_change()",
  "    return portfolio",
  "",
  "# Example usage",
  "if __name__ == '__main__':",
  "    # Portfolio optimization",
  "    tickers = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']",
  "    optimizer = PortfolioOptimizer(tickers, '2023-01-01', '2024-01-01')",
  "    returns = optimizer.fetch_data()",
  "",
  "    # Calculate efficient frontier",
  "    n_assets = len(tickers)",
  "    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})",
  "    bounds = tuple((0, 1) for _ in range(n_assets))",
  "",
  "    # Trading strategy implementation",
  "    strategy = TradingStrategy('SPY', 20, 50)",
  "    spy_data = yf.download('SPY', start='2023-01-01', end='2024-01-01')",
  "    signals = strategy.moving_average_strategy(spy_data)",
  "",
  "    # Risk management",
  "    risk_manager = RiskManager(100000)",
  "    position_size = risk_manager.calculate_position_size(",
  "        risk_per_trade=0.02, entry_price=400, stop_loss=380)",
  "",
  "    # Options pricing",
  "    call_price = black_scholes_call(S=100, K=105, T=0.25, ",
  "                                   r=0.05, sigma=0.2)",
  "    print(f'Call option price: ${call_price:.2f}')",
  "",
  "    # Monte Carlo simulation",
  "    price_paths = monte_carlo_simulation(S0=100, mu=0.1, ",
  "                                        sigma=0.2, T=1)",
  "    final_prices = price_paths[:, -1]",
  "    print(f'Expected final price: ${np.mean(final_prices):.2f}')",
];
